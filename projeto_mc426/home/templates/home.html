<h1>Home Page</h1>

{% load static %}
{% load webpush_notifications %}
<!--Redireciona para um feedback geral-->

{% if request.user.is_authenticated %} 
<p><a href="{% url 'feedback:feedback' %}">Deixe aqui o seu feedback</a></p>

<p><a href="/auth/logout">Sair</a></p>

{% else %}

<p><a href="/auth/login">Entrar</a></p>

{% endif %}

<!--Redireciona para a pagina de admin caso verifique superusuario-->
{% if request.user.is_superuser %} 
    <p><a href="/admin">Acesse a página como um administrador</a></p>
{% endif %}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mapa de Calor do Crime</title>
    <!-- Include Leaflet.js -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <!-- Include Heatmap.js -->
    <script src="{% static 'projeto_mc426/js/heatmap.js' %}"></script>
    <script src="{% static 'projeto_mc426/js/leaflet-heatmap.js' %}"></script>

    <!-- Include Leaflet Routing Machine  -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" />
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>

    <!-- Leaflet Routing Machine - OpenRoute Service -->
    <script src="https://unpkg.com/@gegeweb/leaflet-routing-machine-openroute@latest/dist/leaflet-routing-openroute.js"></script>

    <!-- jquery -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
 {% webpush_header %}
</head>
<body>

    {% webpush_button %}
    <div id="map" style="height: 500px;"></div>
    <script>
        var data = {
            max: 10,
            min: 0,
            data: [
              {%for registro in data%}
                {lat: {{ registro.rdo_lat|stringformat:"f" }}, lng: {{ registro.rdo_lng|stringformat:"f" }}, count: {{ registro.rdo_tdo.tdo_peso }}},
              {%endfor%}
            ]
        };

        // Camada base
        var baseLayer = L.tileLayer(
          'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
            attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://cloudmade.com">CloudMade</a>',
            maxZoom: 18
          }
        );

        var cfg = {
            "radius": 0.0005,
            "maxOpacity": .8,
            "minOpacity": 0, 
            // scales the radius based on map zoom
            "scaleRadius": true, 
            // if set to false the heatmap uses the global maximum for colorization
            // if activated: uses the data maximum within the current map boundaries 
            //   (there will always be a red spot with useLocalExtremas true)
            "useLocalExtrema": false,
            // which field name in your data represents the latitude - default "lat"
            latField: 'lat',
            // which field name in your data represents the longitude - default "lng"
            lngField: 'lng',
            // which field name in your data represents the data value - default "value"
            valueField: 'count'
          };

        var heatmapLayer = new HeatmapOverlay(cfg)

        // Configuração do mapa
        var map = new L.Map('map', {
            center: new L.LatLng(-22.817168, -47.069791),
            zoom: 15,
            layers: [baseLayer, heatmapLayer]
          });

        heatmapLayer.setData(data);

        layer = heatmapLayer;

        // ROUTING

        function getPolygons(data, L){
            var list = [];
            var dist = 0.00015;
            var ocurr = data.data;
            for (const i in ocurr){
                var pol = [];
                L.marker([ocurr[i].lat, ocurr[i].lng]).addTo(map);

                pol.push([ocurr[i].lng - dist, ocurr[i].lat - dist]);
                L.marker([ocurr[i].lat + dist, ocurr[i].lng - dist]).addTo(map);

                pol.push([ocurr[i].lng - dist, ocurr[i].lat + dist]);
                L.marker([ocurr[i].lat - dist, ocurr[i].lng - dist]).addTo(map);

                pol.push([ocurr[i].lng + dist, ocurr[i].lat + dist]);
                L.marker([ocurr[i].lat - dist, ocurr[i].lng + dist]).addTo(map);

                pol.push([ocurr[i].lng + dist, ocurr[i].lat - dist]);
                L.marker([ocurr[i].lat + dist, ocurr[i].lng + dist]).addTo(map);

                pol.push([ocurr[i].lng - dist, ocurr[i].lat - dist]);
                L.marker([ocurr[i].lat + dist, ocurr[i].lng - dist]).addTo(map);
                list.push([pol]);
            }
            return list;
        }


        const apikey = "";
        const osrRouter = new L.Routing.OpenRouteService(apikey, {
                "timeout": 30 * 1000, // 30",
                "format": "json",                           // default, gpx not yet supported
                "host": "https://api.openrouteservice.org", // default if not setting
                "service": "directions",                    // default (for routing) 
                "api_version": "v2",                        // default
                "profile": "cycling-road",                  // default
                "routingQueryParams": {
                    "attributes": [
                        "avgspeed",
                        "percentage"
                    ],
                    "language": "pt-pt",
                    "maneuvers": "true",
                    "preference": "recommended",
                  "options": {
                      "avoid_polygons": {
                          "type": "MultiPolygon",
                          "coordinates": getPolygons(data, L)
                         }
                    }
                }
        });

        var routeCtrl = L.Routing.control({
            router: osrRouter,
            waypoints: [
                L.latLng(-22.82578415192047, -47.072228935407814),
                L.latLng(-22.82384289829194, -47.07019292913905)
            ]
        }).addTo(map);
 

        let hijack = true
        function success(position){
            var lat, lng;
            if (hijack){
                var waypts = routeCtrl.getWaypoints();
                lat = (waypts[0].latLng.lat);
                lng = (waypts[0].latLng.lng);
            } else {
                lat = position.coords.latitude;
                lng = position.coords.longitude;
            }
            var csrf = $(this).attr('csrf');
            $.ajax({
                    type: "POST",
                    url: '/home/update_user_location/',
                    data: {
                        "lat": lat,
                        "lng": lng,
                    },
                    headers:{
                        "X-CSRFToken": '{{ csrf_token }}'
                    },
                    success: function (data) {
                        //alert("successfull")
                    },
                    failure: function () {
                        //alert("failure");
                    }
            });
            console.log(lat);
            console.log(lng);
            // sessionStorage.setItem("user_lat", lat);
            // sessionStorage.setItem("user_lng", lng);
        }

        function error(position){
            console.log(error) 
        }
    // options -> high acuracy
    let id = navigator.geolocation.watchPosition(success, error);
    </script>
</body>
</html>
